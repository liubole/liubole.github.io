{"meta":{"title":"夜色","subtitle":"","description":"农民工","author":"Tricolor","url":"https://liubole.github.io"},"pages":[{"title":"categories","date":"2021-09-05T15:21:18.000Z","updated":"2021-09-05T15:22:19.176Z","comments":true,"path":"categories/index.html","permalink":"https://liubole.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2021-09-05T15:21:48.000Z","updated":"2021-09-05T15:22:16.007Z","comments":true,"path":"tags/index.html","permalink":"https://liubole.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"","slug":"golang内建函数","date":"2021-09-07T03:17:03.602Z","updated":"2021-09-07T03:32:40.970Z","comments":true,"path":"2021/09/07/golang内建函数/","link":"","permalink":"https://liubole.github.io/2021/09/07/golang%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/","excerpt":"\ntitle: golang基本知识tags: [golang]categories: [Golang,其他]toc: falsedate: 2021-09-07 11:16:55\n\ngolang作用域：声明和作用域 https://golang.org/ref/spec#Declarations_and_scope","text":"title: golang基本知识tags: [golang]categories: [Golang,其他]toc: falsedate: 2021-09-07 11:16:55 golang作用域：声明和作用域 https://golang.org/ref/spec#Declarations_and_scope Go 在词法范围内使用blocks： 预先声明的标识符的范围是 Universe 块。 表示在顶层（任何函数之外）声明的常量、类型、变量或函数（但不是方法）的标识符的范围是包块。 导入包的包名的范围是包含导入声明的文件的文件块。 表示方法接收器、函数参数或结果变量的标识符的范围是函数体。 在函数内声明的常量或变量标识符的范围从 ConstSpec 或 VarSpec（短变量声明的 ShortVarDecl）的末尾开始，并在最里面的包含块的末尾结束。 在函数内声明的类型标识符的范围从 TypeSpec 中的标识符开始，并在最里面的包含块的末尾结束。 在块中声明的标识符可以在内部块中重新声明。虽然内部声明的标识符在范围内，但它表示内部声明所声明的实体。 所述包子句是不声明; 包名不会出现在任何范围内。其目的是识别属于同一包的文件并为导入声明指定默认包名称。 golang关键字：bool、byte、error、true、iota甚至int都难道都不是关键字？没错！和其他语言不同，这些标识符并不是关键字，在Go中它们被称为预定义标识符 golang预定义标识符： 作用域：universe 预定义标识符可被override。可覆盖后借助 %T 查看新类型 golang内建函数： 内建函数其实并没有自己的实现源码，编译期间内建函数被替换为若干runtime的调用。可以借助 compile 查看。go tool compile -S innerfunc.go &gt; innerfunc.s","raw":null,"content":null,"categories":[],"tags":[]},{"title":"golang make预先分配空间","slug":"golang make预先分配空间","date":"2021-09-07T02:50:05.000Z","updated":"2021-09-07T03:39:10.452Z","comments":true,"path":"2021/09/07/golang make预先分配空间/","link":"","permalink":"https://liubole.github.io/2021/09/07/golang%20make%E9%A2%84%E5%85%88%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4/","excerpt":"使用make给slice初始化时，不建议在一开始就分配很大空间，除非特别清楚slice的变化过程。\n比如如下代码：\n12345678910111213141516package mainimport (\t&quot;fmt&quot;)func main() &#123;    s := make([]byte, 0, 32)    println(s)    s1 := append(s, &#x27;a&#x27;)    println(s1)    s2 := append(s, &#x27;b&#x27;)    println(s2)\tfmt.Println(string(s1), string(s2))&#125;\n\n代码输出：\n[0/32]0xc000072f30\n[1/32]0xc000072f30\n[1/32]0xc000072f30\nb b","text":"使用make给slice初始化时，不建议在一开始就分配很大空间，除非特别清楚slice的变化过程。 比如如下代码： 12345678910111213141516package mainimport ( &quot;fmt&quot;)func main() &#123; s := make([]byte, 0, 32) println(s) s1 := append(s, &#x27;a&#x27;) println(s1) s2 := append(s, &#x27;b&#x27;) println(s2) fmt.Println(string(s1), string(s2))&#125; 代码输出： [0/32]0xc000072f30 [1/32]0xc000072f30 [1/32]0xc000072f30 b bs、s1、s2都是相同地址。出现这种情况的原因是 append 函数，在 cap 还能容纳元素的情况下，append 仅仅使用copy将元素复制到slice，不会重新申请空间： The append built-in function appends elements to the end of a slice. If it has sufficient capacity, the destination is resliced to accommodate the new elements. If it does not, a new underlying array will be allocated.","raw":null,"content":null,"categories":[{"name":"Golang","slug":"Golang","permalink":"https://liubole.github.io/categories/Golang/"},{"name":"make","slug":"Golang/make","permalink":"https://liubole.github.io/categories/Golang/make/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liubole.github.io/tags/golang/"}]},{"title":"找出毒药","slug":"老鼠找毒药","date":"2021-08-19T03:20:44.000Z","updated":"2021-09-05T15:17:04.538Z","comments":true,"path":"2021/08/19/老鼠找毒药/","link":"","permalink":"https://liubole.github.io/2021/08/19/%E8%80%81%E9%BC%A0%E6%89%BE%E6%AF%92%E8%8D%AF/","excerpt":"一、8瓶药里1瓶毒药，至少需要多少老鼠老鼠找出毒药的一般问题类型是m瓶药，其中一瓶是毒药，用n只老鼠来检测，求n最小多少。\n问题的最小规模是8瓶药，3只老鼠。明面和暗含的条件有\n\nm瓶药里只有一瓶毒药；\n毒药立马发作；\n所有老鼠同时喝药；\n\n答案是2^3=8，故3只老鼠即可。具体方案是：瓶子0-7号（0号瓶所有老鼠都不喝。如果M1 M2 M3都没死，那0号就是毒药）：","text":"一、8瓶药里1瓶毒药，至少需要多少老鼠老鼠找出毒药的一般问题类型是m瓶药，其中一瓶是毒药，用n只老鼠来检测，求n最小多少。 问题的最小规模是8瓶药，3只老鼠。明面和暗含的条件有 m瓶药里只有一瓶毒药； 毒药立马发作； 所有老鼠同时喝药； 答案是2^3=8，故3只老鼠即可。具体方案是：瓶子0-7号（0号瓶所有老鼠都不喝。如果M1 M2 M3都没死，那0号就是毒药）： 鼠M1: 1+3+5+7 鼠M2: 2+3+6+7 鼠M3: 4+5+6+7 方案的本质是，每只老鼠都喝4瓶药，且任意两只老鼠喝的药有且只有2瓶是一样的。所以下面方案也可以： 鼠M1: 0+1+4+5 鼠M2: 0+2+4+6 鼠M3: 0+3+5+6 鼠M1: 1+4+5+7 鼠M2: 2+4+6+7 鼠M3: 3+5+6+7 鼠M1: 1+4+6+7 鼠M2: 2+4+5+7 鼠M3: 3+6+5+7 鼠M1: 1+4+6+0 鼠M2: 2+4+5+0 鼠M3: 3+6+5+0 采用二进制来理解的方案，图示如下： 表1： 鼠↓ 瓶→ 0号 1号 2号 3号 4号 5号 6号 7号 鼠M1 0 1 0 1 0 1 0 1 鼠M2 0 0 1 1 0 0 1 1 鼠M3 0 0 0 0 1 1 1 1 二、1000瓶药里1瓶毒药，喝药15分见效，总共60分种，至少需要多少老鼠如果按前面的思路，一次性找出毒药需要 $\\lceil \\log_2{1000} \\rceil$=10只老鼠没问题，可是60分钟内找出的毒药该如何解？我们可以使用n维坐标系分析，或者使用n进制给瓶子编号，这里的n指的是喝药次数+1。 采用三进制来理解的方案，图示如下： 表2： 鼠↓ 瓶→ 0号 1号 2号 3号 4号 5号 6号 7号 8号 鼠M1 0 1 2 0 1 2 0 1 2 鼠M2 0 0 0 1 1 1 2 2 2 从上面可以推测出，n瓶药里有1瓶毒药，喝药见效时间pt，总时间t，需要老鼠的通用公式为：喝的轮数 c = $\\lfloor t/pt \\rfloor$需要老鼠 m = $\\lceil \\log_{c+1}{n} \\rceil$ 三、1000瓶药里1瓶毒药，喝药15分见效，总共60分种，用最少的老鼠写出老鼠喝药的具体方案从表2可以得出，正常情况下（最后一轮才出现老鼠死亡的情况）喝药方案： 表2： 第一轮 第二轮 M1 0+3+6 1+4+7 M2 0+1+2 3+4+5 如果中途出现老鼠死亡，剩下的老鼠去喝可能导致死亡的药即可（递归）。 喝药方案代码如下，考虑到中途可能有减员，故只给出了前两轮喝药方案： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293func bottleToCheck(die []int, live []int, ret map[int][]uint64) []uint64 &#123; sDie := make([]uint64, 0) sLive := make([]uint64, 0) for _, v := range die &#123; sDie = append(sDie, ret[v]...) &#125; for _, v := range live &#123; sLive = append(sLive, ret[v]...) &#125; inArray := func(i uint64, arr []uint64) bool &#123; for _, v := range arr &#123; if v == i &#123; return true &#125; &#125; return false &#125; rt := make([]uint64, 0) for _, v := range sDie &#123; if inArray(v, sLive) &#123; continue &#125; rt = append(rt, v) &#125; return rt&#125;func rSolution(bottle/*需要检测的瓶子*/ []uint64, mouse/*剩余老鼠编号*/ []int, k/*计算第k轮的喝药方案*/ int, n/**进制*/ int) map[int][]uint64 &#123; solution := make(map[int][]uint64) strRightAt := func(str string, at int) int &#123; var i int if len(str)-at-1 &lt; 0 &#123; i = 0 &#125; else &#123; i, _ = strconv.Atoi(str[len(str)-at-1 : len(str)-at]) &#125; return i &#125; for _, mv := range mouse &#123; for _, dv := range bottle &#123; str := strconv.FormatUint(dv, n) i := strRightAt(str, mv) if i == k &#123; solution[mv] = append(solution[mv], dv) &#125; &#125; &#125; return solution&#125;func logXyCeil(x, y float64) float64 &#123; a, b := math.Frexp(x) c, d := math.Frexp(y) e := (math.Log(c)*(1/math.Ln2) + float64(d)) / (math.Log(a)*(1/math.Ln2) + float64(b)) return math.Ceil(e)&#125;func main() &#123; b := 81 /*瓶子数量*/ n := 2 /*喝药轮数*/ m := int(logXyCeil(float64(n+1), float64(b))) /*共m只老鼠*/ fmt.Printf(&quot;瓶子数量：%d，总喝药轮数：%d，老鼠数量: %d\\n&quot;, b, n, m) var bottle = make([]uint64, 0) var mouse = make([]int, 0) var k int for i := 0; i&lt;m;i++ &#123; mouse = append(mouse, i) &#125; for i := uint64(0); i&lt;uint64(b); i++ &#123; bottle = append(bottle, i) &#125; k = 0 ret := rSolution(bottle, mouse, k, n+1) fmt.Printf(&quot;第%d轮方案：\\n&quot;, k) for i, v := range ret &#123; fmt.Printf(&quot;M%d:\\t %v\\n&quot;, i, v) &#125; //假设喝完第0轮，M0死亡，其他老鼠存活。那第1轮的喝药方案应该是： bottle = bottleToCheck([]int&#123;0&#125;, []int&#123;1, 2, 3&#125;, ret) mouse = []int&#123;1, 2, 3&#125; k = 1 ret = rSolution(bottle, mouse, k, n+1) fmt.Printf(&quot;第%d轮方案：\\n&quot;, k) for i, v := range ret &#123; fmt.Printf(&quot;M%d:\\t %v\\n&quot;, i, v) &#125;&#125; 三、1000瓶药里2瓶毒药，喝药15分见效，总共60分种，用最少的老鼠写出老鼠喝药的具体方案todo","raw":null,"content":null,"categories":[],"tags":[{"name":"找出毒药","slug":"找出毒药","permalink":"https://liubole.github.io/tags/%E6%89%BE%E5%87%BA%E6%AF%92%E8%8D%AF/"}]},{"title":"markdown样式","slug":"markdown样式","date":"2021-08-18T02:19:44.000Z","updated":"2021-09-06T11:56:46.000Z","comments":true,"path":"2021/08/18/markdown样式/","link":"","permalink":"https://liubole.github.io/2021/08/18/markdown%E6%A0%B7%E5%BC%8F/","excerpt":"h1 Headingh2 Headingh3 Headingh4 Headingh5 Heading","text":"h1 Headingh2 Headingh3 Headingh4 Headingh5 Headingh6 HeadingHorizontal Rules EmphasisThis is bold text This is bold text This is italic text This is italic text Strikethrough Blockquotes Blockquotes can also be nested… …by using additional greater-than signs right next to each other… …or with spaces between arrows. ListsUnordered Create a list by starting a line with +, -, or * Sub-lists are made by indenting 2 spaces: Marker character change forces new list start: Ac tristique libero volutpat at Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Very easy! Ordered Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa You can use sequential numbers… …or keep all the numbers as 1. Start numbering with offset: foo bar CodeInline code Indented code 1234// Some commentsline 1 of codeline 2 of codeline 3 of code Block code “fences” 1Sample text here... Syntax highlighting 12345var foo = function (bar) &#123; return bar++;&#125;;console.log(foo(5)); Tables Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. et extension to be used for dest files. Right aligned columns Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. Linkslink text Images Emojies😄 😆 😵 😭 😰 😅 😢 😤 😍 😌👍 👎 💯 👏 🔔 🎁 ❓ 💣 ❤️ ☕️ 🌀 🙇 💋 🙏 💢 Task task 1 task 2 task 3 Hide details Abstract Here are the details. mathematical formulasMultiline formula block： $$\\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}}{1+\\cdots}}}} $$ Inline formula： formula $a^2 + b^2 = \\color{red}c^2$ mind maps1234567- demo- Heading - Emphasis - Blockquotes - Lists - Code - Tables Gantt charts123456789gantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task :a1, 2019-01-01, 30d Another task :after a1 , 20d section Another Task in sec :2019-01-12 , 12d another task : 24d timing charts12345sequenceDiagram Alice-&gt;&gt;John: Hello John, how are you? loop Every minute John--&gt;&gt;Alice: Great! end charts12345678910111213141516171819&#123; &quot;title&quot;: &#123; &quot;text&quot;: &quot;30 day&quot; &#125;, &quot;tooltip&quot;: &#123; &quot;trigger&quot;: &quot;axis&quot;, &quot;axisPointer&quot;: &#123; &quot;lineStyle&quot;: &#123; &quot;width&quot;: 0 &#125; &#125; &#125;, &quot;legend&quot;: &#123; &quot;data&quot;: [ &quot;user&quot;] &#125;, &quot;xAxis&quot;: [&#123; &quot;type&quot;: &quot;category&quot;, &quot;boundaryGap&quot;: false, &quot;data&quot;: [&quot;2019-05-08&quot;,&quot;2019-05-09&quot;,&quot;2019-05-10&quot;,&quot;2019-05-11&quot;,&quot;2019-05-12&quot;,&quot;2019-05-13&quot;,&quot;2019-05-14&quot;,&quot;2019-05-15&quot;,&quot;2019-05-16&quot;,&quot;2019-05-17&quot;,&quot;2019-05-18&quot;,&quot;2019-05-19&quot;,&quot;2019-05-20&quot;,&quot;2019-05-21&quot;,&quot;2019-05-22&quot;,&quot;2019-05-23&quot;,&quot;2019-05-24&quot;,&quot;2019-05-25&quot;,&quot;2019-05-26&quot;,&quot;2019-05-27&quot;,&quot;2019-05-28&quot;,&quot;2019-05-29&quot;,&quot;2019-05-30&quot;,&quot;2019-05-31&quot;,&quot;2019-06-01&quot;,&quot;2019-06-02&quot;,&quot;2019-06-03&quot;,&quot;2019-06-04&quot;,&quot;2019-06-05&quot;,&quot;2019-06-06&quot;,&quot;2019-06-07&quot;], &quot;axisTick&quot;: &#123; &quot;show&quot;: false &#125;, &quot;axisLine&quot;: &#123; &quot;show&quot;: false &#125; &#125;], &quot;yAxis&quot;: [&#123; &quot;type&quot;: &quot;value&quot;, &quot;axisTick&quot;: &#123; &quot;show&quot;: false &#125;, &quot;axisLine&quot;: &#123; &quot;show&quot;: false &#125;, &quot;splitLine&quot;: &#123; &quot;lineStyle&quot;: &#123; &quot;color&quot;: &quot;rgba(0, 0, 0, .38)&quot;, &quot;type&quot;: &quot;dashed&quot; &#125; &#125; &#125;], &quot;series&quot;: [ &#123; &quot;name&quot;: &quot;user&quot;, &quot;type&quot;: &quot;line&quot;, &quot;smooth&quot;: true, &quot;itemStyle&quot;: &#123; &quot;color&quot;: &quot;#f1e05a&quot; &#125;, &quot;areaStyle&quot;: &#123; &quot;normal&quot;: &#123;&#125; &#125;, &quot;z&quot;: 2, &quot;data&quot;: [&quot;31&quot;,&quot;33&quot;,&quot;30&quot;,&quot;23&quot;,&quot;16&quot;,&quot;29&quot;,&quot;23&quot;,&quot;37&quot;,&quot;41&quot;,&quot;29&quot;,&quot;16&quot;,&quot;13&quot;,&quot;39&quot;,&quot;23&quot;,&quot;38&quot;,&quot;136&quot;,&quot;89&quot;,&quot;35&quot;,&quot;22&quot;,&quot;50&quot;,&quot;57&quot;,&quot;47&quot;,&quot;36&quot;,&quot;59&quot;,&quot;14&quot;,&quot;23&quot;,&quot;46&quot;,&quot;44&quot;,&quot;51&quot;,&quot;43&quot;,&quot;0&quot;] &#125; ]&#125; graphviz rendering123456789101112131415digraph finite_state_machine &#123; rankdir=LR; size=&quot;8,5&quot; node [shape = doublecircle]; S; node [shape = point ]; qi node [shape = circle]; qi -&gt; S; S -&gt; q1 [ label = &quot;a&quot; ]; S -&gt; S [ label = &quot;a&quot; ]; q1 -&gt; S [ label = &quot;a&quot; ]; q1 -&gt; q2 [ label = &quot;ddb&quot; ]; q2 -&gt; q1 [ label = &quot;b&quot; ]; q2 -&gt; q2 [ label = &quot;b&quot; ];&#125; Flowchart12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op","raw":null,"content":null,"categories":[{"name":"markdown","slug":"markdown","permalink":"https://liubole.github.io/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://liubole.github.io/tags/markdown/"},{"name":"示例","slug":"示例","permalink":"https://liubole.github.io/tags/%E7%A4%BA%E4%BE%8B/"}]},{"title":"InnoDB索引和使用","slug":"InnoDB索引和使用","date":"2018-12-20T03:09:37.000Z","updated":"2021-09-06T12:48:58.772Z","comments":true,"path":"2018/12/20/InnoDB索引和使用/","link":"","permalink":"https://liubole.github.io/2018/12/20/InnoDB%E7%B4%A2%E5%BC%95%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"了解B+树前，先了解一下二叉查找树和平衡二叉树。二叉查找树规定（非严谨定义）左子树键值小于根键值，根键值小于右子树键值。//二叉树查找树图片\n平衡二叉树在二叉查找树的基础上，还要求任意节点的左右子树高度差不超过1，目的是通过降低树的高度来减少查询次数。//平衡二叉树图片\nB+树的定义较为复杂，先看一个高度为2的B+树：//B+树图片","text":"了解B+树前，先了解一下二叉查找树和平衡二叉树。二叉查找树规定（非严谨定义）左子树键值小于根键值，根键值小于右子树键值。//二叉树查找树图片 平衡二叉树在二叉查找树的基础上，还要求任意节点的左右子树高度差不超过1，目的是通过降低树的高度来减少查询次数。//平衡二叉树图片 B+树的定义较为复杂，先看一个高度为2的B+树：//B+树图片 父节点的值都能在子节点里找到，叶子节点包含了所有的值。同时叶子节点上的值单调递增，节点和节点之间有双向索引。 InnoDB中的索引结构B+树结构聚集索引，叶子节点包含键值和数据页地址。数据页里存放了行数据//图辅助索引，叶子节点包含键值和聚集索引键，用聚集索引键去聚集索引查找数据。由此看出，通过聚集索引找数据更直接，更快。//图 索引的部分应用联合索引覆盖索引MRRICP不使用索引的情况 4.SQL语句where条件提取 5.实际SQL分析","raw":null,"content":null,"categories":[{"name":"数据库","slug":"数据库","permalink":"https://liubole.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"innodb","slug":"数据库/innodb","permalink":"https://liubole.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/innodb/"}],"tags":[{"name":"索引","slug":"索引","permalink":"https://liubole.github.io/tags/%E7%B4%A2%E5%BC%95/"}]},{"title":"深入理解Git","slug":"深入理解Git","date":"2018-03-27T01:13:27.000Z","updated":"2021-09-06T12:48:58.776Z","comments":true,"path":"2018/03/27/深入理解Git/","link":"","permalink":"https://liubole.github.io/2018/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Git/","excerpt":"","text":"Git是一套内容寻址(content-addressable)文件系统","raw":null,"content":null,"categories":[{"name":"仓库","slug":"仓库","permalink":"https://liubole.github.io/categories/%E4%BB%93%E5%BA%93/"},{"name":"git","slug":"仓库/git","permalink":"https://liubole.github.io/categories/%E4%BB%93%E5%BA%93/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://liubole.github.io/tags/git/"},{"name":"git原理","slug":"git原理","permalink":"https://liubole.github.io/tags/git%E5%8E%9F%E7%90%86/"}]},{"title":"Docker环境变量","slug":"Docker环境变量","date":"2017-07-17T02:46:05.000Z","updated":"2021-09-06T12:54:46.328Z","comments":true,"path":"2017/07/17/Docker环境变量/","link":"","permalink":"https://liubole.github.io/2017/07/17/Docker%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"","text":"通过执行docker-compose所在的shell环境注入 12web: image: &quot;webapp:$&#123;TAG&#125;&quot; 通过文件注入2.1 默认使用.env中的变量 12 $ cat .envTAG=v1.5 12345$ cat docker-compose.ymlversion: &#x27;2.0&#x27;services: web: image: &quot;webapp:$&#123;TAG&#125;&quot; 2.2 指定环境变量文件 12345//同docker run –env-file=web-variables.env//docker-compose -f web-variables.envweb: env_file: - web-variables.env 通过docker-compose.yml注入 1234//同docker run -e DEBUG=1web: environment: - DEBUG=1 1234//同docker run -e DEBUGweb: environment: - DEBUG //无赋值的环境变量 通过启动命令注入 123docker run docker run -e DEBUG=1 docker run -e DEBUG // VARIABLE从shell环境变量中获取，同第1条 123docker-compose run docker-compose run -e DEBUG=1 docker-compose run -e DEBUG // VARIABLE从shell环境变量中获取，同第1条 优先级从大到小 12345Shell Compose fileEnvironment fileDockerfileVariable is not defined","raw":null,"content":null,"categories":[{"name":"容器","slug":"容器","permalink":"https://liubole.github.io/categories/%E5%AE%B9%E5%99%A8/"},{"name":"docker","slug":"容器/docker","permalink":"https://liubole.github.io/categories/%E5%AE%B9%E5%99%A8/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://liubole.github.io/tags/docker/"}]},{"title":"CodeIgniter钩子和autoload相冲突的BUG：无法使用autoload","slug":"CodeIgniter钩子和autoload相冲突的BUG：无法使用autoload","date":"2017-05-17T01:50:09.000Z","updated":"2021-09-06T12:48:58.777Z","comments":true,"path":"2017/05/17/CodeIgniter钩子和autoload相冲突的BUG：无法使用autoload/","link":"","permalink":"https://liubole.github.io/2017/05/17/CodeIgniter%E9%92%A9%E5%AD%90%E5%92%8Cautoload%E7%9B%B8%E5%86%B2%E7%AA%81%E7%9A%84BUG%EF%BC%9A%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8autoload/","excerpt":"BUG出现的原因是未正确使用钩子——至少没有按Codeigniter的要求来使用：我们的钩子类继承了CI_Controller，但阅读源码后发现不能这么干。\n当我们 new 一个自己定义的 Controller 的时候（发生在 system/core/Codeigniter.php），CI_Controller 的构造方法会被执行，存储于静态变量$_is_loaded（可以通过is_loaded()调用）里的类都会被传入load_class()加载一遍，而 load_class 方法在引入文件后，不会直接 new 一个传入的类，它会先给传入的类名加上 CI_ 前缀再创建对象。即 new “CI_{$class}”。问题就出现在这里。\nload_class给传入的类名自动加 CI_ 前缀是写死在代码里的，不能通过传入其他参数改变它的行为。个人猜测这样做是为了防止开发者滥用 load_class：框架维护人员通过 load_class 加载框架核心类，开发者使用 Loader 来加载业务相关的类。解决问题的方法就是，保证每次用户访问最多执行一次 CI_Controller 的构造方法。如果要在钩子里使用 Loader（例如 load-&gt;model()、load-&gt;database()），可以使用全局的 &amp;get_instance() 得到的 CI_Controller全局静态实例来加载。\n123456//使用CI_Controller的全局静态实例$this-&gt;ci =&amp; get_instance();$this-&gt;ci-&gt;load =&amp; load_class(&#x27;Loader&#x27;, &#x27;core&#x27;);$this-&gt;ci-&gt;load-&gt;model(&#x27;api_model&#x27;);$this-&gt;ci-&gt;api_model-&gt;setCaller($this-&gt;appid);//model里正常连接数据库","text":"BUG出现的原因是未正确使用钩子——至少没有按Codeigniter的要求来使用：我们的钩子类继承了CI_Controller，但阅读源码后发现不能这么干。 当我们 new 一个自己定义的 Controller 的时候（发生在 system/core/Codeigniter.php），CI_Controller 的构造方法会被执行，存储于静态变量$_is_loaded（可以通过is_loaded()调用）里的类都会被传入load_class()加载一遍，而 load_class 方法在引入文件后，不会直接 new 一个传入的类，它会先给传入的类名加上 CI_ 前缀再创建对象。即 new “CI_{$class}”。问题就出现在这里。 load_class给传入的类名自动加 CI_ 前缀是写死在代码里的，不能通过传入其他参数改变它的行为。个人猜测这样做是为了防止开发者滥用 load_class：框架维护人员通过 load_class 加载框架核心类，开发者使用 Loader 来加载业务相关的类。解决问题的方法就是，保证每次用户访问最多执行一次 CI_Controller 的构造方法。如果要在钩子里使用 Loader（例如 load-&gt;model()、load-&gt;database()），可以使用全局的 &amp;get_instance() 得到的 CI_Controller全局静态实例来加载。 123456//使用CI_Controller的全局静态实例$this-&gt;ci =&amp; get_instance();$this-&gt;ci-&gt;load =&amp; load_class(&#x27;Loader&#x27;, &#x27;core&#x27;);$this-&gt;ci-&gt;load-&gt;model(&#x27;api_model&#x27;);$this-&gt;ci-&gt;api_model-&gt;setCaller($this-&gt;appid);//model里正常连接数据库 记得修改config/hooks里的filepath，指向 hooks 目录（默认在APPPATH下）","raw":null,"content":null,"categories":[{"name":"PHP","slug":"PHP","permalink":"https://liubole.github.io/categories/PHP/"},{"name":"codeigniter","slug":"PHP/codeigniter","permalink":"https://liubole.github.io/categories/PHP/codeigniter/"}],"tags":[{"name":"autoload","slug":"autoload","permalink":"https://liubole.github.io/tags/autoload/"},{"name":"codeigniter","slug":"codeigniter","permalink":"https://liubole.github.io/tags/codeigniter/"},{"name":"hooks","slug":"hooks","permalink":"https://liubole.github.io/tags/hooks/"}]},{"title":"提高前端和后端的对接效率","slug":"提高前端和后端的对接效率","date":"2017-04-20T03:36:42.000Z","updated":"2021-09-06T13:09:42.302Z","comments":true,"path":"2017/04/20/提高前端和后端的对接效率/","link":"","permalink":"https://liubole.github.io/2017/04/20/%E6%8F%90%E9%AB%98%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF%E7%9A%84%E5%AF%B9%E6%8E%A5%E6%95%88%E7%8E%87/","excerpt":"一、基本\n模块化适用\n\n对象创建\n\nmodel模板\n\n\n\n\n二、后端交互\n和后端的交互就是数据的变换过程：收集、传输、展示 （目前只有少量处理数据）\n\n三、数据、操作的验证：触发-反馈","text":"一、基本 模块化适用 对象创建 model模板 二、后端交互 和后端的交互就是数据的变换过程：收集、传输、展示 （目前只有少量处理数据） 三、数据、操作的验证：触发-反馈 监听事件 判断 页面预先保存有数据，直接用JS判断 需要后端实时判断 更改DOM 更改JS数据 四、入手 从功能入手，判断交互接口有哪些： 后端需要提供哪些接口； 前端需要提供哪些数据； 把数据获取都改为调用方法： 直接取变量也可以； 在不知道如果组织变量、不清楚变量数据结构是否合理时，先写成方法更好； 正确获取数据： 数据格式 JS原始类型 - PHP数据类型 原始类型 –&gt; 原始类型 数组 –&gt; 索引数组 对象 –&gt; 关联数组 dataType: json 实时监听 $(dom).trigger(); Array.push Array.splice Array.indexOf 数据操作 类型转换: Number()、parseInt 默认值: || 遍历: Array.forEach(function(value, index) &#123;&#125;); $.each(array, function(index, value) &#123;&#125;); for (var i = 0; i &lt; Array.length; i++) &#123;&#125; DOM操作: 隐藏、显示 动画 style更改 定时器 setTimeout setInterval clearInterval 正确展示数据: 更新局部数据 更新整个dom模块的数据（重新调用生成这个dom的方法） 数据、用户操作的检查: 同步 12if (check() !== true) return;do(); 异步 12ajax: success: function() &#123; do(); &#125; 五、总结1、多看书 2、多练习 3、多优化","raw":null,"content":null,"categories":[{"name":"其他","slug":"其他","permalink":"https://liubole.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"前后端","slug":"前后端","permalink":"https://liubole.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF/"},{"name":"开发","slug":"开发","permalink":"https://liubole.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"消息系统的使用心得 rabbitmq_redis","slug":"消息系统的使用心得 rabbitmq_redis","date":"2017-03-20T02:53:04.000Z","updated":"2021-09-06T12:54:12.313Z","comments":true,"path":"2017/03/20/消息系统的使用心得 rabbitmq_redis/","link":"","permalink":"https://liubole.github.io/2017/03/20/%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%20rabbitmq_redis/","excerpt":"使用rabbitmq和redis有一段时间了，有一些心得体会：rabbitmq使用的php-amqplib，exchange使用的direct，消息持久化，1h后过期；队列自动删除，7天后过期；\n监听消息时的优缺点：rabbitmq：\n缺点：\n    1. 一个消费者只能监听一个消息，遇到【消息：动作 = N:1】的时候，要多开几个进程；\n    2. 为了在控制面板查看进程有没有启动，需要给每个队列指定一个名字；\n    3. 必须显式ack/nack；\n\n优点：\n    1. 可以先publish后subscribe。对于publish、subscribe分开上线的情形，可以先上线publish部分；\n    2. 允许一定的消息累积；\n    3. 消息丢失风险可以控制到很低；\n    4. 用来发送需要延时的消息（微信模板/短信/邮件）；\n    5. 消息太多的时候，可以开多个进程，轮流接收处理消息；redis：\n缺点：\n    1. sub端断开的时候会丢失消息（crontab五个星号不是常驻的意思，仅仅表示每分钟都会执行）；\n    2. 进程容易自动结束（1分钟左右）；\n    3. 必须先开sub端，再pub消息，否则会丢失；\n优点：\n    1. 可以同时监听多个队列的消息；\n    2. 使用很方便，不需要关注消息过期，队列名字之类的；","text":"使用rabbitmq和redis有一段时间了，有一些心得体会：rabbitmq使用的php-amqplib，exchange使用的direct，消息持久化，1h后过期；队列自动删除，7天后过期； 监听消息时的优缺点：rabbitmq： 缺点： 1. 一个消费者只能监听一个消息，遇到【消息：动作 = N:1】的时候，要多开几个进程； 2. 为了在控制面板查看进程有没有启动，需要给每个队列指定一个名字； 3. 必须显式ack/nack； 优点： 1. 可以先publish后subscribe。对于publish、subscribe分开上线的情形，可以先上线publish部分； 2. 允许一定的消息累积； 3. 消息丢失风险可以控制到很低； 4. 用来发送需要延时的消息（微信模板/短信/邮件）； 5. 消息太多的时候，可以开多个进程，轮流接收处理消息；redis： 缺点： 1. sub端断开的时候会丢失消息（crontab五个星号不是常驻的意思，仅仅表示每分钟都会执行）； 2. 进程容易自动结束（1分钟左右）； 3. 必须先开sub端，再pub消息，否则会丢失； 优点： 1. 可以同时监听多个队列的消息； 2. 使用很方便，不需要关注消息过期，队列名字之类的；现状： 1. 和金钱相关的地方对“消息丢失”很敏感，踩过坑； 2. “延时消息”用于发送微信会话（首次关注后不能立即发送）； 3. 知道一个队列名字对于调试、程序阅读的帮助并不大； 4. 没出现过“消息太多，一个进程处理不过来”的情况； 5. 消息的发送和接收，逐渐变多了，有变混乱的情况；改进： 对于现状1-4，提出以下改进: 1. 保留延时消息功能，保留持久化机制，保留死信机制； 2. 取消rabbitmq的队列名字（默认一个无意义字符串）； 3. 如果修改队列名字，注意在修改后删掉以前的队列，并重启监听脚本；","raw":null,"content":null,"categories":[{"name":"中间件","slug":"中间件","permalink":"https://liubole.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"rabbitmq","slug":"中间件/rabbitmq","permalink":"https://liubole.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/rabbitmq/"}],"tags":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://liubole.github.io/tags/rabbitmq/"},{"name":"redis","slug":"redis","permalink":"https://liubole.github.io/tags/redis/"},{"name":"消息系统","slug":"消息系统","permalink":"https://liubole.github.io/tags/%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F/"}]},{"title":"深入理解CI框架：数据库的加载过程","slug":"深入理解CI框架：数据库的加载过程","date":"2017-02-15T08:48:30.000Z","updated":"2021-09-06T13:09:12.071Z","comments":true,"path":"2017/02/15/深入理解CI框架：数据库的加载过程/","link":"","permalink":"https://liubole.github.io/2017/02/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CI%E6%A1%86%E6%9E%B6%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"说明：没特别指明的情况下，本文涉及的Codeigniter均为3.1.2版。\n\n要在 CI 框架里使用数据库，你可以显示地加载它：\n1$this-&gt;load-&gt;database(db_to_load);\n也可以在加载 model 的时候顺带加载数据库：","text":"说明：没特别指明的情况下，本文涉及的Codeigniter均为3.1.2版。 要在 CI 框架里使用数据库，你可以显示地加载它： 1$this-&gt;load-&gt;database(db_to_load); 也可以在加载 model 的时候顺带加载数据库： 12// 第三个参数$this-&gt;load-&gt;model(model_to_load, name, db_to_load); 当我们只有一个数据库的时候，上面两种方法都行得通。默认情况下，CI 把数据库连接赋值给一个叫 db 的属性。但如果有多个数据库(&gt;=2)，并且要经常切换，就只能使用 database() 并且第二个参数传 true，例如： 1$this-&gt;dblink = $this-&gt;load-&gt;database(db_to_load, true);//return ? 我们看一下 database() 方法的部分实现细节： 1234567891011121314// database() 方法开头会判断 db 是否已被赋值if ($return === FALSE &amp;&amp; $query_builder === NULL &amp;&amp; isset($CI-&gt;db) &amp;&amp; is_object($CI-&gt;db) &amp;&amp; ! empty($CI-&gt;db-&gt;conn_id))&#123; return FALSE;&#125;...// 返回数据库连接if ($return === TRUE)&#123; return DB($params, $query_builder);&#125;...// 赋值给 db$CI-&gt;db =&amp; DB($params, $query_builder); 看得出来，每次执行 database(db_to_load, true) 的时候都会连接一次数据库，所以在必要时才 load model。 注：1. 上面指的是调用 database(db_to_load, true)；不是 database(db_to_load)；2. 读者事先看过 DB() 方法，知道 DB() 会去连数据库 o(￣▽￣)o 。 下面是 DB() 方法的部分实现细节： 123456789...//此处有很多 include 和 require_once...// $params[&#x27;dbdriver&#x27;] 在配置数据库时指定，比如 mysql$driver = &#x27;CI_DB_&#x27;.$params[&#x27;dbdriver&#x27;].&#x27;_driver&#x27;;$DB = new $driver($params);...// $driver 继承的某个抽象类有 initialize() 方法$DB-&gt;initialize(); 下面是 initialize() 方法的部分实现细节： 12345678910111213/* * 这是 CI_DB_driver 类 */// 防止重复连接数据库，但是只在这样调用时才起作用： $this-&gt;load-&gt;database(db); 注意第二个参数。if ($this-&gt;conn_id)&#123; return TRUE;&#125;// db_connect 由继承该类的派生类实现$this-&gt;conn_id = $this-&gt;db_connect($this-&gt;pconnect);...// 最后设置mysql(客户端)编码return $this-&gt;db_set_charset($this-&gt;char_set); 如果你再深入源码了解 CI_DB_driver 类，你会发现下面的关系链： $driver extends CI_DB { } // drivers 举例： CI_DB_mysql_driver class CI_DB extends CI_DB_query_builder { } // CI_DB 是个空类 // or： class CI_DB extends CI_DB_driver { } abstract class CI_DB_query_builder extends CI_DB_driver { } abstract class CI_DB_driver { } 上面出现了两个抽象类，它们一个偏向于 Query，一个偏向于 DB，下面是两个类的注释： CI_DB_query_builder : This is the platform-independent base Query Builder implementation class.CI_DB_driver: This is the platform-independent base DB implementation class. CI_DB 是个空类，没有任何实现，但是所有数据库驱动类（例如 CI_DB_mysql_driver）都继承 CI_DB。注意到 &amp;DB(params, query_builder_override) 方法的第二个参数，它决定了 CI_DB 继承 CI_DB_query_builder 还是 CI_DB_driver : 1234567891011if (! isset($query_builder) OR $query_builder === TRUE) &#123; if ( ! class_exists(&#x27;CI_DB&#x27;, FALSE)) &#123; class CI_DB extends CI_DB_query_builder &#123; &#125; &#125;&#125; elseif ( ! class_exists(&#x27;CI_DB&#x27;, FALSE))&#123; class CI_DB extends CI_DB_driver &#123; &#125;&#125; 可以看出来，CI_DB 起到了“适配器”的作用。 完。","raw":null,"content":null,"categories":[{"name":"PHP","slug":"PHP","permalink":"https://liubole.github.io/categories/PHP/"},{"name":"codeigniter","slug":"PHP/codeigniter","permalink":"https://liubole.github.io/categories/PHP/codeigniter/"}],"tags":[{"name":"codeigniter","slug":"codeigniter","permalink":"https://liubole.github.io/tags/codeigniter/"}]},{"title":"深入理解CI框架：框架如何运转起来（实践篇）","slug":"深入理解CI框架：框架如何运转起来（实践篇）","date":"2016-12-30T06:24:52.000Z","updated":"2021-09-06T12:58:05.687Z","comments":true,"path":"2016/12/30/深入理解CI框架：框架如何运转起来（实践篇）/","link":"","permalink":"https://liubole.github.io/2016/12/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CI%E6%A1%86%E6%9E%B6%EF%BC%9A%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E8%BF%90%E8%BD%AC%E8%B5%B7%E6%9D%A5%EF%BC%88%E5%AE%9E%E8%B7%B5%E7%AF%87%EF%BC%89/","excerpt":"说明：没特别指明的情况下，本文涉及的Codeigniter均为3.1.2版。\n\n本篇文章所展示的代码就是：浓（阉）缩（割）后的codeigniter框架，目的就是让大家看明白ci框架的构成和运行始末。有些地方和CI不一样，比如我这里用了controller基类来加载model和view，实际上CI是通过CI_Loader来做的，希望我这样做不会对你们理解CI框架造成影响。\n###准备工作：\n\n1、apache rewrite\n12345&gt;RewriteEngine OnRewriteBase /RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule ^(.*)$ index.php?/$1 [L]\n2、目录结构（强烈建议把下面的文件放到域名根目录下 =￣ω￣= ，这关系到index.php的路径解析）：\n","text":"说明：没特别指明的情况下，本文涉及的Codeigniter均为3.1.2版。 本篇文章所展示的代码就是：浓（阉）缩（割）后的codeigniter框架，目的就是让大家看明白ci框架的构成和运行始末。有些地方和CI不一样，比如我这里用了controller基类来加载model和view，实际上CI是通过CI_Loader来做的，希望我这样做不会对你们理解CI框架造成影响。 ###准备工作： 1、apache rewrite 12345&gt;RewriteEngine OnRewriteBase /RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule ^(.*)$ index.php?/$1 [L] 2、目录结构（强烈建议把下面的文件放到域名根目录下 =￣ω￣= ，这关系到index.php的路径解析）： index.php core controller.php controllers my_controller.php models my_model.php views my_view.php footer.php 3、访问路径（域名按实际情况修改）：http://www.myphp.com/index.php/my_controller/doTest/p1/p2?p=mm ###Step1：index.php 入口文件 1234567891011121314151617//index.php//记得设置url rewrite，所有的请求都要走 index.php$uri = parse_url(&#x27;http://dummy&#x27; . $_SERVER[&#x27;REQUEST_URI&#x27;]);$query = isset($uri[&#x27;query&#x27;]) ? $uri[&#x27;query&#x27;] : &#x27;&#x27;;$path = isset($uri[&#x27;path&#x27;]) ? $uri[&#x27;path&#x27;] : &#x27;&#x27;;$real_path = trim(substr($path, strlen($_SERVER[&#x27;SCRIPT_NAME&#x27;])), &#x27;/&#x27;);//提取 controllers 和 methodlist($class, $method, $args_string) = explode(&#x27;/&#x27;, $real_path, 3);$args = explode(&#x27;/&#x27;, $args_string);//调用方法require_once( __DIR__ . &#x27;/core/controller.php&#x27;);require_once(__DIR__ . &#x27;/controllers/&#x27; . $class . &#x27;.php&#x27;);$_class = new $class();call_user_func_array(array($_class, $method), $args);$_class-&gt;output(); ###Step2：核心 controller 123456789101112131415161718192021222324252627282930313233//core/controller.php//所有控制器均继承该基类，model()和view()方法的作用类似CI_Loder里的model()和view()class controller&#123; private $output = &#x27;&#x27;; public function model($name, $_ = NULL) &#123; $file_path = dirname(__DIR__) . &#x27;/models/&#x27; . $name . &#x27;.php&#x27;; require_once($file_path); return $_ ? new $name() : new $name(array_shift(func_get_args())); &#125; public function view($name, $data = array()) &#123; $file_path = dirname(__DIR__) . &#x27;/views/&#x27; . $name . &#x27;.php&#x27;; ob_start(); extract($data); require($file_path); $output = ob_get_contents(); ob_clean(); @ob_end_clean(); @ob_end_flush(); $this-&gt;output .= $output; &#125; public function output() &#123; echo $this-&gt;output; &#125;&#125; ###Step3：controllers 控制器 1234567891011121314151617181920//controllers/my_controller.phpclass my_controller extends controller&#123; //访问该方法 public function doTest() &#123; //加载模型 $this-&gt;my_model = $this-&gt;model(&#x27;my_model&#x27;); //将值赋值给$this-&gt;data数组 $this-&gt;data[&#x27;title&#x27;] = &#x27;深入理解CI框架&#x27;; $this-&gt;data[&#x27;args&#x27;] = array($arg1, $arg2); $this-&gt;data[&#x27;words&#x27;] = $this-&gt;my_model-&gt;upper(&#x27;hello world!&#x27;); //把值传入到view里面 $this-&gt;view(&#x27;header&#x27;, $this-&gt;data); $this-&gt;view(&#x27;my_view&#x27;, $this-&gt;data); $this-&gt;view(&#x27;footer&#x27;, $this-&gt;data); &#125;&#125; ###Step4：models 模型 123456789//models/my_model.phpclass my_model&#123; //只实现了一个方法，用来演示 public function upper($word) &#123; return strtoupper($word); &#125;&#125; ###Step5：views 视图 123//views/my_view.php&lt;div&gt;&lt;?php echo $words; ?&gt;&lt;/div&gt;&lt;div&gt;args: &lt;?php print_r($args);?&gt;&lt;/div&gt; 12345678910111213141516//views/header.php&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;?php echo $title;?&gt;&lt;/title&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; &lt;meta name=&quot;keyword&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt; &lt;/head&gt;&lt;body&gt; 123//views/footer.php&lt;/body&gt;&lt;/html&gt; ###运行结果 运行后的结果是：HELLO WORLD!args: Array ( [0] =&gt; p1 [1] =&gt; p2 ) 完。","raw":null,"content":null,"categories":[{"name":"PHP","slug":"PHP","permalink":"https://liubole.github.io/categories/PHP/"},{"name":"codeigniter","slug":"PHP/codeigniter","permalink":"https://liubole.github.io/categories/PHP/codeigniter/"}],"tags":[{"name":"codeigniter","slug":"codeigniter","permalink":"https://liubole.github.io/tags/codeigniter/"},{"name":"源码","slug":"源码","permalink":"https://liubole.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"后向引用（Back-Reference）中的 $&","slug":"后向引用（Back-Reference）中的 $&","date":"2016-12-24T08:43:26.000Z","updated":"2021-09-06T12:48:58.773Z","comments":true,"path":"2016/12/24/后向引用（Back-Reference）中的 $&/","link":"","permalink":"https://liubole.github.io/2016/12/24/%E5%90%8E%E5%90%91%E5%BC%95%E7%94%A8%EF%BC%88Back-Reference%EF%BC%89%E4%B8%AD%E7%9A%84%20$&/","excerpt":"今天遇到一个从（shao）未（jian）遇（duo）到（guai）过的正则替换：\n1&#x27;iixxxixx&#x27;.replace(/i+/g, &#x27;($&amp;)&#x27;) // complete match\n虽然注释说明白了这是complete match的意思，但我还是不懂啊（以前只遇到过$加数字），还是搬砖找资料吧  ( ￣ー￣)\n\n送给你们一本讲解正则表达式的书，不谢！《Regular Expressions: The Complete Tutorial》\n\n翻到replacematch这一页：","text":"今天遇到一个从（shao）未（jian）遇（duo）到（guai）过的正则替换： 1&#x27;iixxxixx&#x27;.replace(/i+/g, &#x27;($&amp;)&#x27;) // complete match 虽然注释说明白了这是complete match的意思，但我还是不懂啊（以前只遇到过$加数字），还是搬砖找资料吧 ( ￣ー￣) 送给你们一本讲解正则表达式的书，不谢！《Regular Expressions: The Complete Tutorial》 翻到replacematch这一页： &amp; all by itself represents the whole regex match, while $&amp; is a literal dollar sign followed by the whole regex match, and &amp; is a literal ampersand. 看英文可能会明白一点，&amp;表示 the whole regex match（or each one ?） $&amp; is substituted with the whole regex match in the replacement text in the JGsoft applications, Delphi, .NET, JavaScript, and VBScript 这个符号（$&amp;）只在 JGsoft 应用和 Delphi 等几种语言里可用。 You can do this with $0 in the JGsoft applications, Delphi, .NET, Java, XRegExp, PCRE2, PHP, and XPath. \\0 works with the JGsoft applications, Delphi, Ruby, PHP, and Tcl. $0（JGsoft应用、PHP、Java、XPath等）、\\0（Ruby等）也有相同效果，不同应用、语言里有不同的 literal ampersand。 完。 PS：上面提到的书并没有看完。PS：今天还找到了Speaking JavaScript: An In-Depth Guide for Programmers，我正在看这本书的中文翻译版，有英文版对照好棒 b(￣▽￣)d（HTML比PDF方便多了），开森","raw":null,"content":null,"categories":[{"name":"其他","slug":"其他","permalink":"https://liubole.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"正则","slug":"正则","permalink":"https://liubole.github.io/tags/%E6%AD%A3%E5%88%99/"},{"name":"书籍推荐","slug":"书籍推荐","permalink":"https://liubole.github.io/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"}]},{"title":"深入理解CI框架：框架如何运转起来（原理篇）","slug":"深入理解CI框架：框架如何运转起来（原理篇）","date":"2016-12-19T06:22:04.000Z","updated":"2021-09-06T12:58:05.685Z","comments":true,"path":"2016/12/19/深入理解CI框架：框架如何运转起来（原理篇）/","link":"","permalink":"https://liubole.github.io/2016/12/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CI%E6%A1%86%E6%9E%B6%EF%BC%9A%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E8%BF%90%E8%BD%AC%E8%B5%B7%E6%9D%A5%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/","excerpt":"说明：没特别指明的情况下，本文涉及的Codeigniter均为3.1.2版。\n\n##一、核心###index.php：入口文件入口文件主要定义路径和环境，包括BASEPATH、FCPATH、APPPATH等常量表示的路径和application、system等变量表示的路径；\n\nindex.php通过$_SERVER[&#39;CI_ENV&#39;]来分辨当前的执行环境，目前支持development、testing、production三种（默认development），如果你在apache里配置CI_ENV为其他值（比如mytest），项目会输出错误信息并停止执行；\n\n###core/CodeIgniter.php：分派请求CodeIgniter.php加载了各种各样的类和方法，它解析用户的请求（URI类），判断请求对应哪个控制器的哪个方法（Router类），创建控制器对象，执行方法，得到结果并输出（Output类），期间还会加载并执行预先设置好的各种钩子（Hooks类）。","text":"说明：没特别指明的情况下，本文涉及的Codeigniter均为3.1.2版。 ##一、核心###index.php：入口文件入口文件主要定义路径和环境，包括BASEPATH、FCPATH、APPPATH等常量表示的路径和application、system等变量表示的路径； index.php通过$_SERVER[&#39;CI_ENV&#39;]来分辨当前的执行环境，目前支持development、testing、production三种（默认development），如果你在apache里配置CI_ENV为其他值（比如mytest），项目会输出错误信息并停止执行； ###core/CodeIgniter.php：分派请求CodeIgniter.php加载了各种各样的类和方法，它解析用户的请求（URI类），判断请求对应哪个控制器的哪个方法（Router类），创建控制器对象，执行方法，得到结果并输出（Output类），期间还会加载并执行预先设置好的各种钩子（Hooks类）。 很显然，CodeIgniter.php是CI框架最重要的文件之一，它根据用户请求调用不同类处理并输出结果。 CI框架解析用户请求，判断对应哪个控制器哪个方法时，主要依据$_SERVER这个变量（$_SERVER[&#39;REQUEST_METHOD&#39;]等） 除了各种类，CodeIgniter.php还加载了很多公共方法，详见core/Common.php和core/compat ##二、提取核心代码 1234$RTR =&amp; load_class(&#x27;Router&#x27;, &#x27;core&#x27;);$class = ucfirst($RTR-&gt;class);require_once BASEPATH.&#x27;core/Controller.php&#x27;;$CI = new $class(); ##三、细枝末节###core/Common.php：公共方法Common Functions——这是Common.php定位，用来存放各种公共方法，比如is_php、is_https、is_cli、show_404、function_usable等等。 core/compat目录下也存放有很多公共方法文件，比如hash.php、mbstring.php、password.php、standard.php，我们经常用的array_column函数就是在standard.php里定义的。 ##四、黑科技###extract：从数组中将变量导入到当前的符号表 1234//index.php$vars = array(&#x27;name&#x27; =&gt; &#x27;jane&#x27;, &#x27;age&#x27; =&gt; 20);extract($vars);var_dump($name); ###ob_xxx函数：把输出放到缓冲区、从缓冲区获取内容 ob_start：打开输出控制缓冲ob_end_flush：冲刷出（送出）输出缓冲区内容并关闭缓冲ob_end_clean：清空（擦除）缓冲区并关闭输出缓冲 123456789//index2.php//将一个php文件保存到文本文件里//load-&gt;view 如何实现的ob_start();include(&#x27;./index.php&#x27;);$buffer = ob_get_contents();file_put_contents(&#x27;index.php.txt&#x27;, $buffer);@ob_end_clean();ob_end_flush(); ###ReflectionMethod：反射类 1234567//检查方法是否可以访问//如何在访问一个private方法或不存在的方法的时候显示404$reflection = new ReflectionMethod($class, $method);if ( ! $reflection-&gt;isPublic() OR $reflection-&gt;isConstructor())&#123; $e404 = TRUE;&#125; 完。","raw":null,"content":null,"categories":[{"name":"PHP","slug":"PHP","permalink":"https://liubole.github.io/categories/PHP/"},{"name":"codeigniter","slug":"PHP/codeigniter","permalink":"https://liubole.github.io/categories/PHP/codeigniter/"}],"tags":[{"name":"codeigniter","slug":"codeigniter","permalink":"https://liubole.github.io/tags/codeigniter/"},{"name":"源码","slug":"源码","permalink":"https://liubole.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"post_get 同一个参数传两次","slug":"post_get 同一个参数传两次","date":"2016-12-06T02:35:19.000Z","updated":"2021-09-06T12:55:02.706Z","comments":true,"path":"2016/12/06/post_get 同一个参数传两次/","link":"","permalink":"https://liubole.github.io/2016/12/06/post_get%20%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BC%A0%E4%B8%A4%E6%AC%A1/","excerpt":"最近在做保险业务，遇到一个奇怪（shaojianduoguai）的问题，同一个参数需要传递两次，比如：\n1period=2016-12-12&amp;period=2017-12-12\n\n本来在php里，经常用array来传递、接收post参数，array的特点是同一个键名唯一，所以肯定不能简单地用array传递参数了。 (′д｀ )…彡…彡\n\nPOST可以传递两个相同名字的参数吗？","text":"最近在做保险业务，遇到一个奇怪（shaojianduoguai）的问题，同一个参数需要传递两次，比如： 1period=2016-12-12&amp;period=2017-12-12 本来在php里，经常用array来传递、接收post参数，array的特点是同一个键名唯一，所以肯定不能简单地用array传递参数了。 (′д｀ )…彡…彡 POST可以传递两个相同名字的参数吗？可以。下面是测试代码： 123456789101112131415161718192021//index.php:function post($url, $para)&#123; $curl = curl_init($url); curl_setopt($curl, CURLOPT_HEADER, 0); // 过滤HTTP头 curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);// 显示输出结果 curl_setopt($curl, CURLOPT_POST, true); // post传输数据 curl_setopt($curl, CURLOPT_POSTFIELDS, $para);// post传输数据 $responseText = curl_exec($curl); curl_close($curl); return $responseText;&#125;$url = &quot;local.soft.com/sub.php&quot;;$res = post($url, &#x27;period=2016-12-12&amp;period=2017-12-12&#x27;);var_dump(unserialize($res));//string(35) &quot;period=2016-12-12&amp;period=2017-12-12&quot;//sub.phpecho serialize(file_get_contents(&quot;php://input&quot;));die(); 既然POST可以传递，那么GET呢？测试发现GET也可以： 123456789101112131415161718//index.phpfunction get($url)&#123; $curl = curl_init($url); curl_setopt($curl, CURLOPT_HEADER, 0); curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); $responseText = curl_exec($curl); curl_close($curl); echo $responseText;&#125;$url = &quot;local.soft.com/sub.php?period=2016-12-12&amp;period=2017-12-12&quot;;get($url);//sub.phpvar_dump($_SERVER[&#x27;QUERY_STRING&#x27;]);die(); 结论：GET和POST都可以传递两个相同名字的参数","raw":null,"content":null,"categories":[{"name":"网络","slug":"网络","permalink":"https://liubole.github.io/categories/%E7%BD%91%E7%BB%9C/"},{"name":"http","slug":"网络/http","permalink":"https://liubole.github.io/categories/%E7%BD%91%E7%BB%9C/http/"}],"tags":[{"name":"post","slug":"post","permalink":"https://liubole.github.io/tags/post/"}]},{"title":"rabbitmq分享","slug":"rabbitmq分享","date":"2016-11-09T13:58:09.000Z","updated":"2021-09-06T12:54:12.316Z","comments":true,"path":"2016/11/09/rabbitmq分享/","link":"","permalink":"https://liubole.github.io/2016/11/09/rabbitmq%E5%88%86%E4%BA%AB/","excerpt":"消息队列（MessageQueue）：简化业务流程异步处理消息减少组件耦合消减数据峰值\n场景1：    支付成功以后，给用户发送优惠券or红包；场景2：    用户注册成功后发送通知邮件or短信；场景3：    活动里面的站内信发送；……总结起来就是，把单个业务简洁化，通过消息系统把不相关的业务连接起来，实现更复杂的业务链，降低整个系统的复杂度。\n安装省略。。。\n使用四个重要概念：虚拟主机（vhost）、交换器（exchange）、队列（queue）、绑定（binding）\n先说交换器和队列，附带消息的说明：","text":"消息队列（MessageQueue）：简化业务流程异步处理消息减少组件耦合消减数据峰值 场景1： 支付成功以后，给用户发送优惠券or红包；场景2： 用户注册成功后发送通知邮件or短信；场景3： 活动里面的站内信发送；……总结起来就是，把单个业务简洁化，通过消息系统把不相关的业务连接起来，实现更复杂的业务链，降低整个系统的复杂度。 安装省略。。。 使用四个重要概念：虚拟主机（vhost）、交换器（exchange）、队列（queue）、绑定（binding） 先说交换器和队列，附带消息的说明： 队列属性（部分）： 名称(queue)： 持久化(durable)：服务重启后是否要恢复 自动删除(auto-delete)：没有消费者时自动删除 其他声明： 消息存在时间(x-message-ttl)： 队列存在时间(x-expires)：交换器属性（部分）： 名称(exchange)： 类型(type)：fanout/direct/topic/headers 持久化(durable)：服务重启后是否要恢复 自动删除(auto-delete)：没有队列使用交换器时自动删除消息（部分）： 消息体(body) 属性（properties）： 投递模式(delivery_mode)：可设置为持久化绑定（exchange-queue）： 和交换器、队列不一样，绑定是一种规则而非实体。 *持久化和自动删除并不冲突*队列、交换器的属性设置好后就不能修改，除非删掉重建 在我们的项目中是如何使用RabbitMQ的： 持久化：要达到一般人理解的持久保存消息，需要设置三个地方 1.将交换机设置成durable； 2.将队列设置成durable； 3.将消息的delivery_mode设置成2； 注意两点：1.缺少任何一个，都无法达成真正持久化消息的目的； 2.持久化会消耗额外的性能； 自动删除：消息&amp;队列生存时间、“死信队列”这些都是自己设置的。 消息在队列里存在时间是1分钟，队列本身存在时间是30分钟，过期的消息会被移出到“死信队列”，死信队列里的消息存在7天，死信队列本身存在10天；消息消费后ack/nack机制(acknowledgement)： 如果能保证消息已经被正确消费了，你可以通过ack方法告诉rabbitmq，rabbitmq会删除这条消息； 反之，你可以调用nack告诉RabbitMQ消费失败（rabbitmq会将消息立马移到“死信队列”），或者什么都不做（等待消息过期被移动到“死信队列”）。 发布消息后confirm机制：暂时关闭了这个功能。 发布消息后，发送者可以通过异步的回调知道消息是否发送成功。 代码：use CI123\\Shop\\Tool\\RabbitMq\\Publisher;Publisher::publish(‘coupons.user_coupon.add’, json_encode($coupons)); use Api\\Tool\\RabbitMq\\Subscriber;Subscriber::subscribe(‘shop_com.add.trade_deliver’, function ($msgObj) { $message = $msgObj-&gt;body; Subscriber::ack($msgObj);}); 其他，关于RabbitMQ的知识很多也比较琐碎，建议大家直接提问。","raw":null,"content":null,"categories":[{"name":"中间件","slug":"中间件","permalink":"https://liubole.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"rabbitmq","slug":"中间件/rabbitmq","permalink":"https://liubole.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/rabbitmq/"}],"tags":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://liubole.github.io/tags/rabbitmq/"}]},{"title":"linux p命令粘贴到何处","slug":"linux p命令粘贴到何处","date":"2016-10-28T09:55:56.000Z","updated":"2021-09-06T12:48:58.775Z","comments":true,"path":"2016/10/28/linux p命令粘贴到何处/","link":"","permalink":"https://liubole.github.io/2016/10/28/linux%20p%E5%91%BD%E4%BB%A4%E7%B2%98%E8%B4%B4%E5%88%B0%E4%BD%95%E5%A4%84/","excerpt":"","text":"dd-&gt;p:粘贴到光标的下一行nyy-p:粘贴到光标的下一行ndd-&gt;p:粘贴到光标的下一行v模式-&gt;y-&gt;p:在光标处粘贴，被粘贴内容插入在光标所在的位置i模式-&gt;鼠标右键粘贴：在光标处粘贴，被粘贴内容插入在光标所在的位置","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://liubole.github.io/categories/Linux/"}],"tags":[{"name":"linux命令","slug":"linux命令","permalink":"https://liubole.github.io/tags/linux%E5%91%BD%E4%BB%A4/"}]},{"title":"php echo中的逗号","slug":"php echo中的逗号","date":"2016-10-12T03:45:51.000Z","updated":"2021-09-06T12:48:58.775Z","comments":true,"path":"2016/10/12/php echo中的逗号/","link":"","permalink":"https://liubole.github.io/2016/10/12/php%20echo%E4%B8%AD%E7%9A%84%E9%80%97%E5%8F%B7/","excerpt":"","text":"才疏学浅，第一次发现echo可以用逗号echo ‘x’ . 1 + 5; //输出 6echo ‘x’ , 1 + 5; //输出 x6 暂时理解为逗号是将 echo 当方法用","raw":null,"content":null,"categories":[{"name":"PHP","slug":"PHP","permalink":"https://liubole.github.io/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"https://liubole.github.io/tags/php/"},{"name":"echo","slug":"echo","permalink":"https://liubole.github.io/tags/echo/"}]},{"title":"ueditor图片显示顺序和上传顺序不一致","slug":"ueditor图片显示顺序和上传顺序不一致","date":"2016-10-10T03:38:07.000Z","updated":"2021-09-06T12:48:58.775Z","comments":true,"path":"2016/10/10/ueditor图片显示顺序和上传顺序不一致/","link":"","permalink":"https://liubole.github.io/2016/10/10/ueditor%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E9%A1%BA%E5%BA%8F%E5%92%8C%E4%B8%8A%E4%BC%A0%E9%A1%BA%E5%BA%8F%E4%B8%8D%E4%B8%80%E8%87%B4/","excerpt":"问题如题所示，运营觉得这个bug很严重必须改，作为好员工我去看了ueditor的源码。注：ueditor版本是【UEditor1.4.3】\n首先问题可以细分为两个：1、从上传图片到把图片存到数组，这个过程中图片的顺序有没有改变；2、把保存的图片显示出来，这个过程中图片的顺序有没有改变；\n先看第一个问题，单步调试，发现关键代码如下（在image.js中）：\n1_this.imageList.push(json);\n上面保存图片的方式不会改变图片的顺序，问题一无影响的可能性很高；","text":"问题如题所示，运营觉得这个bug很严重必须改，作为好员工我去看了ueditor的源码。注：ueditor版本是【UEditor1.4.3】 首先问题可以细分为两个：1、从上传图片到把图片存到数组，这个过程中图片的顺序有没有改变；2、把保存的图片显示出来，这个过程中图片的顺序有没有改变； 先看第一个问题，单步调试，发现关键代码如下（在image.js中）： 1_this.imageList.push(json); 上面保存图片的方式不会改变图片的顺序，问题一无影响的可能性很高； 再看第二个问题，在ueditor.all.js（or ueditor.all.min.js，看具体情况）中，有个 insertimage 方法，这个方法会把图片显示到富文本框，发现一段代码是设置图片顺序的（在最新的ueditor中未见这段代码，应该是修复bug时去掉了）： 1234567891011121314151617181920for (var i=0; ci=opt[i];i++)&#123; var name = ci.src; var tmp = new Array(); tmp = name.split(&quot;?&quot;); ci.src = tmp[0]; var tmp2 = tmp[1]; tmp = tmp2.split(&quot;=&quot;); tmp = tmp[1].split(&quot;.&quot;);+- ci.pos = parseInt(tmp[0]); if(!ci.pos)&#123; tmp = tmp[0].split(&quot;_&quot;); if(tmp[1])&#123; ci.pos = parseInt(tmp[1]); &#125;else&#123; ci.pos=100; &#125; &#125; ci.pos = i + 1; opt[i] = ci;&#125; 从上面的代码可以发现，如果图片链接包含参数，图片的排列顺序就会受到参数的影响，而我这里的图片链接刚好有参数，参数还是以数字结尾的 ； /(ㄒoㄒ)/~~ 删掉代码，需求搞定。","raw":null,"content":null,"categories":[{"name":"其他","slug":"其他","permalink":"https://liubole.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"ueditor","slug":"ueditor","permalink":"https://liubole.github.io/tags/ueditor/"}]},{"title":"PHP中用json_decode()无法解析有换行符的字符串","slug":"PHP中用json_decode()无法解析有换行符的字符串","date":"2016-09-30T08:48:39.000Z","updated":"2021-09-06T12:48:58.775Z","comments":true,"path":"2016/09/30/PHP中用json_decode()无法解析有换行符的字符串/","link":"","permalink":"https://liubole.github.io/2016/09/30/PHP%E4%B8%AD%E7%94%A8json_decode()%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E6%9C%89%E6%8D%A2%E8%A1%8C%E7%AC%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"$temp_mes_data = array ( ‘state’ =&gt; ‘on’, ‘temp_mess_id’ =&gt; ‘2IWKf1L7pbfFcqCBfzIB-P9coclpprUwwY2PkEPot1g’, ‘temp_content’ =&gt; array ( ‘first’ =&gt; array ( ‘value’ =&gt; ‘您刚刚收到了一笔{pay_fee}元的新订单’, ), ‘keyword1’ =&gt; array ( ‘value’ =&gt; ‘{unique_id}’, ), ‘keyword2’ =&gt; array ( ‘value’ =&gt; ‘{info}’, ), ‘keyword3’ =&gt; array ( ‘value’ =&gt; ‘{member}’, ), ‘keyword4’ =&gt; array ( ‘value’ =&gt; ‘{mobile}’, ), ‘keyword5’ =&gt; array ( ‘value’ =&gt; ‘{address}’, ), ‘remark’ =&gt; array ( ‘value’ =&gt; ‘点击这里查看订单详情’, ), ), ‘url’ =&gt; ‘http://shop.ci123.com/yiqigou/store_entity/orderDetail/{trade_id}?store_id={store_id}&#39;,);$data = array ( ‘store_id’ =&gt; ‘302’, ‘trade_id’ =&gt; ‘203245’, ‘pay_fee’ =&gt; ‘0.01’, ‘unique_id’ =&gt; ‘1609301545079469’, ‘info’ =&gt; ‘贝拉小蜜蜂 5-12岁儿童牙膏防蛀健齿牙牙疼宝宝牙膏 x1’, ‘member’ =&gt; ‘‘, ‘mobile’ =&gt; ‘’, ‘address’ =&gt; ‘’,); $temp_mes_data = json_encode($temp_mes_data);foreach ($data as $k =&gt; $v) { $temp_mes_data = str_replace(“{$k}”, $v, $temp_mes_data);}$temp_mes_data = json_decode($temp_mes_data);var_dump($temp_mes_data); 在此输入正文","raw":null,"content":null,"categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://liubole.github.io/categories/Javascript/"}],"tags":[{"name":"未分类","slug":"未分类","permalink":"https://liubole.github.io/tags/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"jquery解析json数据，得到的是数组还是对象？","slug":"jquery解析json数据，得到的是数组还是对象？","date":"2016-09-21T02:22:58.000Z","updated":"2021-09-06T12:48:58.771Z","comments":true,"path":"2016/09/21/jquery解析json数据，得到的是数组还是对象？/","link":"","permalink":"https://liubole.github.io/2016/09/21/jquery%E8%A7%A3%E6%9E%90json%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%BE%97%E5%88%B0%E7%9A%84%E6%98%AF%E6%95%B0%E7%BB%84%E8%BF%98%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9F/","excerpt":"","text":"//todo","raw":null,"content":null,"categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://liubole.github.io/categories/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://liubole.github.io/tags/js/"},{"name":"javascript","slug":"javascript","permalink":"https://liubole.github.io/tags/javascript/"}]},{"title":"如何同时遍历js中的数组和对象","slug":"如何同时遍历js中的数组和对象","date":"2016-09-21T01:54:43.000Z","updated":"2021-09-07T03:07:58.677Z","comments":true,"path":"2016/09/21/如何同时遍历js中的数组和对象/","link":"","permalink":"https://liubole.github.io/2016/09/21/%E5%A6%82%E4%BD%95%E5%90%8C%E6%97%B6%E9%81%8D%E5%8E%86js%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"同样的数据从服务器取得并解码后（json数据），在js端呈现两种不同的结果，一为数组，一为对象，暂且不讨论问题的原因（待解决），这里讨论解决办法。\n开始以为只会遍历数组，没考虑到会遍历对象，所以用了 for（对象无length属性所以失败）。\nforEach 只能用于数组，不能用于对象；for 需要长度作为循环终止条件，对象没有length属性，也不考虑；for in 可以同时遍历数组和对象，符合条件；\n1234var searches = &#123;state:1,page:2&#125;;for (var key in params) &#123;    searches[key] = params[key];&#125;\n\nObject.keys() 先把对象或属性取出来得到数组a，然后遍历a，相当于在遍历数组和对象，也符合条件；","text":"同样的数据从服务器取得并解码后（json数据），在js端呈现两种不同的结果，一为数组，一为对象，暂且不讨论问题的原因（待解决），这里讨论解决办法。 开始以为只会遍历数组，没考虑到会遍历对象，所以用了 for（对象无length属性所以失败）。 forEach 只能用于数组，不能用于对象；for 需要长度作为循环终止条件，对象没有length属性，也不考虑；for in 可以同时遍历数组和对象，符合条件； 1234var searches = &#123;state:1,page:2&#125;;for (var key in params) &#123; searches[key] = params[key];&#125; Object.keys() 先把对象或属性取出来得到数组a，然后遍历a，相当于在遍历数组和对象，也符合条件； var p = data[i] || data.i;//不论data是数组还是对象，都可以取到值","raw":null,"content":null,"categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://liubole.github.io/categories/Javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://liubole.github.io/tags/js/"}]},{"title":"PHP二维数组排序","slug":"PHP二维数组排序","date":"2016-09-08T09:37:53.000Z","updated":"2021-09-06T12:58:34.777Z","comments":true,"path":"2016/09/08/PHP二维数组排序/","link":"","permalink":"https://liubole.github.io/2016/09/08/PHP%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/","excerpt":"","text":"思路：将 array (key =&gt; array) 转换为 array (key =&gt; array中的待排序字段)，降维为一维数组排序，然后将一维数组的value替换为原始数组对应key的value。 二维数组排序的时间复杂度等同一维数组排序的时间复杂度。同理推测，n维数组排序的时间复杂度等同一维数组排序的时间复杂度。","raw":null,"content":null,"categories":[{"name":"PHP","slug":"PHP","permalink":"https://liubole.github.io/categories/PHP/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://liubole.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"判断点是否在矩形内的算法","slug":"判断点是否在矩形内的算法","date":"2016-09-07T10:06:09.000Z","updated":"2021-09-06T12:59:37.323Z","comments":true,"path":"2016/09/07/判断点是否在矩形内的算法/","link":"","permalink":"https://liubole.github.io/2016/09/07/%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E7%9F%A9%E5%BD%A2%E5%86%85%E7%9A%84%E7%AE%97%E6%B3%95/","excerpt":"需求描述：有一个 4*4 的方格，用户可以选择起点和落点形成矩形，每次形成的矩形不能重叠，起点可以和落点坐标一样。现已知起点、未选点集合和已选点集合，求落点的集合。\n算法重点：转换为判断点P是否在一个矩形内。\n\n###方法一：建立平面直角坐标系，根据横坐标和纵坐标判断点是否在矩形内。\n1234567891011121314/** * 判断点是否在矩形内（含边）。p1、p2是矩形的两个对角点。 * 该算法和平面直角坐标系怎么建立无关 * @param $rc * @param $p * @return bool */function isInRect($rc, $p)&#123;    $xi = ($p-&gt;x - $rc-&gt;p1-&gt;x) * ($p-&gt;x - $rc-&gt;p2-&gt;x);    $yi = ($p-&gt;y - $rc-&gt;p1-&gt;y) * ($p-&gt;y - $rc-&gt;p2-&gt;y);    return ($xi &lt;= 0) &amp;&amp; ($yi &lt;= 0);&#125;","text":"需求描述：有一个 4*4 的方格，用户可以选择起点和落点形成矩形，每次形成的矩形不能重叠，起点可以和落点坐标一样。现已知起点、未选点集合和已选点集合，求落点的集合。 算法重点：转换为判断点P是否在一个矩形内。 ###方法一：建立平面直角坐标系，根据横坐标和纵坐标判断点是否在矩形内。 1234567891011121314/** * 判断点是否在矩形内（含边）。p1、p2是矩形的两个对角点。 * 该算法和平面直角坐标系怎么建立无关 * @param $rc * @param $p * @return bool */function isInRect($rc, $p)&#123; $xi = ($p-&gt;x - $rc-&gt;p1-&gt;x) * ($p-&gt;x - $rc-&gt;p2-&gt;x); $yi = ($p-&gt;y - $rc-&gt;p1-&gt;y) * ($p-&gt;y - $rc-&gt;p2-&gt;y); return ($xi &lt;= 0) &amp;&amp; ($yi &lt;= 0);&#125; ###方法二：假设矩形左、右、上、下分别在直线 L1、L2、L3、L4 上，只需要证明点 P 同时在上下、左右直线之间即可。 过P作一条直线相交于 L1、L2 的 C1 、C2 ，向量PC1 、PC2 同向则P在 L1、L2 之外，反向则在 L1、L2 之内。同理可判断P是否在 L3、L4 之间。 $$ PC_1 = （C_1x - P_x , C_1y - P_y）; PC_2 = （C_2x - P_x , C_2y - P_y）;$$$$ \\frac{C_2x - P_x}{C_1x - P_x } &gt; 0 或 \\frac{C_2y - P_y}{C_1y - P_y } &gt; 0 =&gt; PC_1、PC_2 同向 $$$$（C_1x-P_x）^2 + （C_1y-P_y）^2 = 0 =&gt; PC_1为零向量 =&gt; PC_1、PC_2 同向$$$$（C_2x-P_x）^2 + （C_2y-P_y）^2 = 0 =&gt; PC_2为零向量 =&gt; PC_1、PC_2 同向$$ 如果：$$ L_1: y = mx + t_1; $$$$ L_2: y = mx + t_2; $$$$ C_1C_2: y = (m+1)x; $$$$ P_1:(P_1x, P_1y); P_2:(P_3x, P_3y) 是L_1上的两个矩形顶点；$$$$ P_3:(P_3x, P_3y); P_4:(P_4x, P_4y) 是L_2上的两个矩形顶点；$$ 则： $$ 若点P和{P_1,P_2,P_3,P_4}中的某一点重合，则P在矩形内；$$$$ 若(t_2 - P_x)(t_1 - P_x)&gt;0, t_1=\\frac{P_1yP_2x-P_1xP_2y}{P_2x-P_1x},t_2=\\frac{P_3yP_4x-P_3xP_4y}{P_4x-P_3x}则P在矩形内；$$$$ 若(t_2 - P_x)(t_1 - P_x)&gt;0, t_1=\\frac{P_1yP_2x-P_1xP_2y}{P_2x-P_1x},t_2=\\frac{P_3yP_4x-P_3xP_4y}{P_4x-P_3x}则P在矩形内；$$ 123/** * 此处省略n行代码 */ ###方法三：以点P为起点，向左作射线，如果射线和矩形的焦点个数是奇数，则P在矩形内。PS：对以下特例不做考虑：1、对于矩形的水平边不作考虑；2、对于矩形的顶点和L相交的情况。 123/** * 此处省略m行代码 */ 总结：方法一简单实用，方法三可以推广到判断点是否在任意多边形内。 本文涉及资料：计算几何算法概览","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"https://liubole.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://liubole.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"利用svn钩子检查语法","slug":"利用svn钩子检查语法","date":"2016-08-31T02:14:32.000Z","updated":"2021-09-06T12:48:58.773Z","comments":true,"path":"2016/08/31/利用svn钩子检查语法/","link":"","permalink":"https://liubole.github.io/2016/08/31/%E5%88%A9%E7%94%A8svn%E9%92%A9%E5%AD%90%E6%A3%80%E6%9F%A5%E8%AF%AD%E6%B3%95/","excerpt":"使用 register_shutdown_function 捕获代码异常的时候，语法错误是无法捕获的，本着及时预防、发现错误的原则，利用 svn 的 hooks 对提交的代码进行语法检查很有必要。\nsvn常见的钩子有：\n\npost-commit：文件提交之后执行post-lock：文件加锁之后执行post-revprop-change：revision 属性修改之后执行post-unlock：文件解锁之后执行pre-commit：文件提交之前执行pre-lock：文件加锁之前执行pre-revprop-change：revision 属性修改之前执行pre-unlock：文件解锁之前执行start-commit：未建立 Subversion transaction 之前执行\n\n这里使用 pre-commit 这个钩子。\nPS：这里遇到一个问题就是不知道svn安装在哪里的。。。最后求助于命令 whereis svn. Yeah!  [更多linux命令][1]","text":"使用 register_shutdown_function 捕获代码异常的时候，语法错误是无法捕获的，本着及时预防、发现错误的原则，利用 svn 的 hooks 对提交的代码进行语法检查很有必要。 svn常见的钩子有： post-commit：文件提交之后执行post-lock：文件加锁之后执行post-revprop-change：revision 属性修改之后执行post-unlock：文件解锁之后执行pre-commit：文件提交之前执行pre-lock：文件加锁之前执行pre-revprop-change：revision 属性修改之前执行pre-unlock：文件解锁之前执行start-commit：未建立 Subversion transaction 之前执行 这里使用 pre-commit 这个钩子。 PS：这里遇到一个问题就是不知道svn安装在哪里的。。。最后求助于命令 whereis svn. Yeah! [更多linux命令][1] [1]:","raw":null,"content":null,"categories":[{"name":"仓库","slug":"仓库","permalink":"https://liubole.github.io/categories/%E4%BB%93%E5%BA%93/"},{"name":"svn","slug":"仓库/svn","permalink":"https://liubole.github.io/categories/%E4%BB%93%E5%BA%93/svn/"}],"tags":[]},{"title":"composer中的autoload","slug":"composer中的autoload","date":"2016-08-26T03:24:36.000Z","updated":"2021-09-06T12:58:27.998Z","comments":true,"path":"2016/08/26/composer中的autoload/","link":"","permalink":"https://liubole.github.io/2016/08/26/composer%E4%B8%AD%E7%9A%84autoload/","excerpt":"","text":"composer作为一款PHP的包管理器，类似于Java中的maven。当我们用composer把需要使用的包下载下来后，借助__autoload() 我们就能直接在项目中使用第三方库了。 composer提供了四种自动加载机制： classmap： psr-0: psr-4: files:","raw":null,"content":null,"categories":[{"name":"PHP","slug":"PHP","permalink":"https://liubole.github.io/categories/PHP/"},{"name":"工具","slug":"PHP/工具","permalink":"https://liubole.github.io/categories/PHP/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"composer","slug":"composer","permalink":"https://liubole.github.io/tags/composer/"},{"name":"PHP自动加载","slug":"PHP自动加载","permalink":"https://liubole.github.io/tags/PHP%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD/"}]},{"title":"spl_autoload_register 入门级讲解","slug":"spl_autoload_register 入门级讲解","date":"2016-08-25T07:35:38.000Z","updated":"2021-09-06T12:59:37.318Z","comments":true,"path":"2016/08/25/spl_autoload_register 入门级讲解/","link":"","permalink":"https://liubole.github.io/2016/08/25/spl_autoload_register%20%E5%85%A5%E9%97%A8%E7%BA%A7%E8%AE%B2%E8%A7%A3/","excerpt":"__autoload()\n\n了解 spl_autoload_register() 前先了解一下 __autoload()，或者直接 跳过此节：\n12345function __autoload($c)&#123;    var_dump($c);&#125;new Say();\n123//输出string(3) &quot;Say&quot;Fatal error: Class &#x27;Say&#x27; not found in E:\\Dropbox\\liubole\\htdocs\\test\\index.php on line xx\n\n当Say类不存在的时候，自动执行了 __autoload() 函数，并将类名当做参数传入了 __autoload()。","text":"__autoload() 了解 spl_autoload_register() 前先了解一下 __autoload()，或者直接 跳过此节： 12345function __autoload($c)&#123; var_dump($c);&#125;new Say(); 123//输出string(3) &quot;Say&quot;Fatal error: Class &#x27;Say&#x27; not found in E:\\Dropbox\\liubole\\htdocs\\test\\index.php on line xx 当Say类不存在的时候，自动执行了 __autoload() 函数，并将类名当做参数传入了 __autoload()。 如果在 __autoload() 里面 include 一下包含 Say 类的文件，可以“亡羊补牢”，代码继续正常执行： 12345678910function __autoload($c)&#123; echo &quot;not fund class \\&quot;&#123;$c&#125;\\&quot;, auto loading...\\n&quot;; //libs下的say.php，大小写无影响 include_once __DIR__ . &quot;/libs/&#123;$c&#125;.php&quot;;&#125;$say = new Say();$say-&gt;hello(); 包含 Say 类（libs/say.php）的文件内容： 123456789101112class Say&#123; function __construct() &#123; echo &quot;init class \\&quot;Say\\&quot;...\\n&quot;; &#125; function hello() &#123; echo &quot;say: hello~\\n&quot;; &#125;&#125; 再次执行，结果如下： 123not fund class &quot;Say&quot;, auto loading...init class &quot;Say&quot;...say: hello~ 至此我们大概了解了 __autoload() 的实际执行情况。 spl_autoload_register() PS：前缀 SPL 的全称是 Standard PHP Library。 当PHP找不到类文件会调用 __autoload() 方法，当注册了自己的函数或方法时，PHP不会调用 __autoload() 函数，而会调用自定义的函数。 如果在你的程序中已经实现了autoload函数，它必须显式注册到autoload栈中。因为spl_autoload_register()函数会将Zend Engine中的__autoload函数取代为spl_autoload()或spl_autoload_call()。 上面的话来自 php.net。OK，那怎样算 显式注册到__autoload栈中 呢？ ◔ ‸◔ … ◔ ‸◔ ….. ◔ ‸◔ …… ◔ ‸◔ ……..◔ ‸◔ 答案是：spl_autoload_register(“__autoload”) 。以下是我找来的一点摘要，描述了为何需要这样做： autoload机制的主要执行过程为：(1) 检查执行器全局变量函数指针autoload_func是否为NULL。(2) 如果autoload_func==NULL，则查找系统中是否定义有autoload()函数，如果没有，则报告错误并退出。(3) 如果定义了autoload()函数，则执行autoload()尝试加载类，并返回加载结果。(4) 如果autoload_func不为NULL，则直接执行autoload_func指针指向的函数用来加载类。注意此时并不检查autoload()函数是否定义。 如果既实现了__autoload()函数，又实现了autoload_func（将autoload_func指向某一PHP函数），那么只执行autoload_func函数。 SPL autoload机制的实现是通过将函数指针autoload_func指向自己实现的具有自动装载功能的函数来实现的。SPL有两个不同的函数spl_autoload， spl_autoload_call，通过将autoload_func指向这两个不同的函数地址来实现不同的自动加载机制。spl_autoload的功能比较简单，而且它是在SPL扩展中实现的，我们无法扩充它的功能。所以我们需要spl_autoload_register将autoload_func指向spl_autoload_call的这个功能。 在SPL模块内部，有一个全局变量autoload_functions，它本质上是一个HashTable，不过我们可以将其简单的看作一个链表，链表中的每一个元素都是一个函数指针，指向一个具有自动加载类功能的函数。spl_autoload_call按顺序执行这个链表中每个函数，在每个函数执行完成后都判断一次需要的类是否已经加载，如果加载成功就直接返回，不再继续执行链表中的其它函数。 自动加载函数链表autoload_functions由spl_autoload_register函数维护，它可以将用户定义的自动加载函数注册到这个链表中，并将autoload_func函数指针指向spl_autoload_call函数。 欲知详情请移步 __autoload机制详解以及与spl_autoload_register的区别， 文章把原因讲的很详细，时间匆忙我仅囫囵吞枣瞄了眼。 本文涉及资料：PHP: spl_autoload_register - Manual __autoload机制详解以及与spl_autoload_register的区别","raw":null,"content":null,"categories":[{"name":"PHP","slug":"PHP","permalink":"https://liubole.github.io/categories/PHP/"}],"tags":[{"name":"PHP自动加载","slug":"PHP自动加载","permalink":"https://liubole.github.io/tags/PHP%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD/"}]},{"title":"妈妈购 Shop_com解析","slug":"妈妈购 Shop_com解析","date":"2016-05-28T14:35:17.000Z","updated":"2021-09-06T12:48:58.774Z","comments":true,"path":"2016/05/28/妈妈购 Shop_com解析/","link":"","permalink":"https://liubole.github.io/2016/05/28/%E5%A6%88%E5%A6%88%E8%B4%AD%20Shop_com%E8%A7%A3%E6%9E%90/","excerpt":"","text":"use HuNanZai\\Component\\Log\\Service as Logger;use Api\\ShopCom\\Model\\UncheckLog;use Api\\ShopCom\\Model\\CheckedLog;use Api\\ShopCom\\Model\\CheckProof;use Api\\ShopCom\\Model\\PayLog; use HuNanZai\\Component\\Log\\Service as Logger;去HuNanZai\\Component\\Log\\Service看源码。涉及到composer。 composer:提供依赖管理+自动加载功能。phpstorm是否支持composer：支持，在windows上安装composer，进入composer.json所在目录，运行composer install -vvvcomposer.json: composer中的autoload：自动加载，基于spl_autoload_register() 函数","raw":null,"content":null,"categories":[{"name":"其他","slug":"其他","permalink":"https://liubole.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"妈妈购","slug":"妈妈购","permalink":"https://liubole.github.io/tags/%E5%A6%88%E5%A6%88%E8%B4%AD/"}]}]}